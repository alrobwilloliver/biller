// Code generated by sqlc. DO NOT EDIT.
// source: lease.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const createLease = `-- name: CreateLease :one
INSERT INTO "lease" (
  id,
  infra_type,
  order_id,
  price_hr
)
VALUES (
  $1,
  $2,
  $3,
  $4
)
ON CONFLICT DO NOTHING
RETURNING id, infra_type, order_id, create_time, end_time, price_hr, status
`

type CreateLeaseParams struct {
	ID        string
	InfraType InfrastructureType
	OrderID   string
	PriceHr   float64
}

func (q *Queries) CreateLease(ctx context.Context, arg CreateLeaseParams) (Lease, error) {
	row := q.db.QueryRow(ctx, createLease,
		arg.ID,
		arg.InfraType,
		arg.OrderID,
		arg.PriceHr,
	)
	var i Lease
	err := row.Scan(
		&i.ID,
		&i.InfraType,
		&i.OrderID,
		&i.CreateTime,
		&i.EndTime,
		&i.PriceHr,
		&i.Status,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO "order" (
  id,
  infra_type,
  billing_account_id,
  project_id,
  quantity,
  description,
  price_hr
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
ON CONFLICT DO NOTHING
RETURNING id, infra_type, project_id, quantity, description, status, create_time, price_hr, billing_account_id
`

type CreateOrderParams struct {
	ID               string
	InfraType        InfrastructureType
	BillingAccountID string
	ProjectID        string
	Quantity         int32
	Description      string
	PriceHr          float64
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.ID,
		arg.InfraType,
		arg.BillingAccountID,
		arg.ProjectID,
		arg.Quantity,
		arg.Description,
		arg.PriceHr,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.InfraType,
		&i.ProjectID,
		&i.Quantity,
		&i.Description,
		&i.Status,
		&i.CreateTime,
		&i.PriceHr,
		&i.BillingAccountID,
	)
	return i, err
}

const endLease = `-- name: EndLease :one
UPDATE "lease"
SET end_time = NOW(),
    status = $1
WHERE id = $2
RETURNING id, infra_type, order_id, create_time, end_time, price_hr, status
`

type EndLeaseParams struct {
	Status LeaseStatus
	ID     string
}

func (q *Queries) EndLease(ctx context.Context, arg EndLeaseParams) (Lease, error) {
	row := q.db.QueryRow(ctx, endLease, arg.Status, arg.ID)
	var i Lease
	err := row.Scan(
		&i.ID,
		&i.InfraType,
		&i.OrderID,
		&i.CreateTime,
		&i.EndTime,
		&i.PriceHr,
		&i.Status,
	)
	return i, err
}

const endOrder = `-- name: EndOrder :one
UPDATE "order"
SET status = $1
WHERE id = $2
RETURNING id, infra_type, project_id, quantity, description, status, create_time, price_hr, billing_account_id
`

type EndOrderParams struct {
	Status OrderStatus
	ID     string
}

func (q *Queries) EndOrder(ctx context.Context, arg EndOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, endOrder, arg.Status, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.InfraType,
		&i.ProjectID,
		&i.Quantity,
		&i.Description,
		&i.Status,
		&i.CreateTime,
		&i.PriceHr,
		&i.BillingAccountID,
	)
	return i, err
}

const findLeaseInfoByLeaseId = `-- name: FindLeaseInfoByLeaseId :one
SELECT lease.id, lease.infra_type, order_id, lease.create_time, end_time, lease.price_hr, lease.status, o.id, o.infra_type, project_id, quantity, description, o.status, o.create_time, o.price_hr, billing_account_id
FROM "lease" lease
         INNER JOIN "order" o ON lease.order_id = o.id
WHERE lease.id = $1
LIMIT 1
`

type FindLeaseInfoByLeaseIdRow struct {
	ID               string
	InfraType        InfrastructureType
	OrderID          string
	CreateTime       time.Time
	EndTime          sql.NullTime
	PriceHr          float64
	Status           LeaseStatus
	ID_2             string
	InfraType_2      InfrastructureType
	ProjectID        string
	Quantity         int32
	Description      string
	Status_2         OrderStatus
	CreateTime_2     time.Time
	PriceHr_2        float64
	BillingAccountID string
}

func (q *Queries) FindLeaseInfoByLeaseId(ctx context.Context, id string) (FindLeaseInfoByLeaseIdRow, error) {
	row := q.db.QueryRow(ctx, findLeaseInfoByLeaseId, id)
	var i FindLeaseInfoByLeaseIdRow
	err := row.Scan(
		&i.ID,
		&i.InfraType,
		&i.OrderID,
		&i.CreateTime,
		&i.EndTime,
		&i.PriceHr,
		&i.Status,
		&i.ID_2,
		&i.InfraType_2,
		&i.ProjectID,
		&i.Quantity,
		&i.Description,
		&i.Status_2,
		&i.CreateTime_2,
		&i.PriceHr_2,
		&i.BillingAccountID,
	)
	return i, err
}

const listActiveLeasesByOrderId = `-- name: ListActiveLeasesByOrderId :many
SELECT id, infra_type, order_id, create_time, end_time, price_hr, status
FROM "lease"
WHERE lease.order_id = $1
  AND status = 'active'
`

func (q *Queries) ListActiveLeasesByOrderId(ctx context.Context, orderID string) ([]Lease, error) {
	rows, err := q.db.Query(ctx, listActiveLeasesByOrderId, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Lease
	for rows.Next() {
		var i Lease
		if err := rows.Scan(
			&i.ID,
			&i.InfraType,
			&i.OrderID,
			&i.CreateTime,
			&i.EndTime,
			&i.PriceHr,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeasesForTimeRangeByOrderId = `-- name: ListLeasesForTimeRangeByOrderId :many
SELECT id, infra_type, order_id, create_time, end_time, price_hr, status
FROM "lease" l
WHERE
  l.order_id = $1 AND
  l.create_time < $2 AND
  (l.end_time IS NULL OR l.end_time >= $3)
`

type ListLeasesForTimeRangeByOrderIdParams struct {
	OrderID   string
	EndTime   time.Time
	StartTime sql.NullTime
}

func (q *Queries) ListLeasesForTimeRangeByOrderId(ctx context.Context, arg ListLeasesForTimeRangeByOrderIdParams) ([]Lease, error) {
	rows, err := q.db.Query(ctx, listLeasesForTimeRangeByOrderId, arg.OrderID, arg.EndTime, arg.StartTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Lease
	for rows.Next() {
		var i Lease
		if err := rows.Scan(
			&i.ID,
			&i.InfraType,
			&i.OrderID,
			&i.CreateTime,
			&i.EndTime,
			&i.PriceHr,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByBillingAccountId = `-- name: ListOrdersByBillingAccountId :many
SELECT id, infra_type, project_id, quantity, description, status, create_time, price_hr, billing_account_id
FROM "order" o
WHERE o.billing_account_id = $1
`

func (q *Queries) ListOrdersByBillingAccountId(ctx context.Context, billingAccountID string) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByBillingAccountId, billingAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.InfraType,
			&i.ProjectID,
			&i.Quantity,
			&i.Description,
			&i.Status,
			&i.CreateTime,
			&i.PriceHr,
			&i.BillingAccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByProjectId = `-- name: ListOrdersByProjectId :many
SELECT id, infra_type, project_id, quantity, description, status, create_time, price_hr, billing_account_id
FROM "order" o
WHERE o.project_id = $1
`

func (q *Queries) ListOrdersByProjectId(ctx context.Context, projectID string) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByProjectId, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.InfraType,
			&i.ProjectID,
			&i.Quantity,
			&i.Description,
			&i.Status,
			&i.CreateTime,
			&i.PriceHr,
			&i.BillingAccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
